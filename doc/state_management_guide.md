# 견고한 상태 중심 애플리케이션을 위한 상태 관리 설계 지침

이 문서는 게임과 같이 복잡하고 동적인 상태 변화를 가지는 애플리케이션에서, 예측 불가능한 버그와 후반부의 복잡도 폭증으로 인한 실패를 막기 위한 구체적인 상태 관리 설계 지침을 제공합니다.

---

### 왜 상태 관리 설계가 중요한가?

상태 중심 애플리케이션의 실패는 대부분 기능의 부재가 아닌 **복잡도 관리의 실패**에서 비롯됩니다. 초기 설계 없이 눈앞의 버그만 수정하다 보면, 상태 변경의 흐름을 아무도 예측할 수 없는 '스파게티 코드'가 만들어지고 결국 프로젝트는 좌초하게 됩니다. 이 지침은 그러한 실패를 예방하는 것을 목표로 합니다.

---

## 4대 핵심 원칙

### 1. 상태 저장소는 "데이터베이스"처럼 다루어라

> 상태 저장소(Store)는 똑똑한 두뇌가 아니라, 무식하고 순수한 창고여야 한다.

-   **지침:**
    -   **오직 데이터와 단순 액션만 허용:** 상태 저장소에는 순수한 데이터(State)와, 그 데이터를 직접 변경하는 가장 단순한 동기적 함수(Action, 예: `setName(newName)`) 외에는 아무것도 두지 마십시오.
    -   **비즈니스 로직 금지:** `async/await`, `setTimeout`, `fetch`, 복잡한 조건 분기 등은 '서비스(Service)' 또는 '컨트롤러(Controller)' 계층으로 분리하십시오. 상태 저장소는 "어떻게"가 아닌 "무엇"만 알아야 합니다.
    -   **예시:**

        ```typescript
        // 👎 나쁜 예: 스토어에 비즈니스 로직이 섞여있다.
        export const useGameStore = create(set => ({
          score: 0,
          fetchAndSetScore: async (userId) => {
            const response = await fetch(`/api/score/${userId}`);
            const data = await response.json();
            set({ score: data.score }); // 예측 불가능한 시점에 상태 변경 발생
          }
        }));
        
        // 👍 좋은 예: 스토어는 순수하고, 로직은 서비스에 있다.
        // GameStore.ts
        export const useGameStore = create(set => ({
          score: 0,
          setScore: (newScore) => set({ score: newScore }),
        }));
        
        // GameService.ts
        export const GameService = {
          updateScore: async (userId) => {
            const response = await fetch(`/api/score/${userId}`);
            const data = await response.json();
            useGameStore.getState().setScore(data.score); // 서비스가 스토어의 액션을 호출
          }
        };
        ```

### 2. "핵심 게임 상태"와 "UI 시각 상태"를 분리하라

> 게임의 규칙과, 그 규칙을 어떻게 보여줄지는 완전히 다른 이야기다.

-   **지침:**
    -   **핵심 게임 상태(Core State):** 게임의 본질. 이 데이터만 있으면 게임을 저장하고 불러올 수 있어야 합니다. (예: `score`, `playerPosition`, `inventory`, `health`)
        -   **관리:** `useGameStore`와 같이 중앙 집중화된 핵심 스토어에서 관리합니다.
    -   **UI 시각 상태(UI/Visual State):** 게임의 규칙과 무관하며, 오직 화면에 어떻게 보여줄지에만 관련된 상태입니다. (예: `isAnimating`, `isModalOpen`, `isLoading`, `isShaking`)
        -   **관리:**
            1.  **로컬 상태(`useState`):** 가장 좋은 방법. 특정 컴포넌트에서만 사용된다면 주저 없이 로컬 상태로 관리하십시오.
            2.  **별도 UI 스토어:** 여러 컴포넌트가 공유해야만 한다면, `useUIStore`와 같이 별도의 스토어를 만들어 핵심 스토어의 오염을 막으십시오.

### 3. 상태 변경은 "단방향 데이터 흐름"을 따라야 한다

> 데이터는 강물처럼 한 방향으로만 흘러야 예측이 가능하다.

-   **지침:**
    -   **흐름 정의:** `사용자 입력(View) → 서비스/액션(Action) → 상태 변경(Store) → 화면 갱신(View)` 이라는 엄격한 단방향 흐름을 강제하십시오.
    -   **역류 금지:** 뷰(컴포넌트)가 중간 단계(서비스)를 건너뛰고 스토어를 직접 수정하거나, 다른 컴포넌트의 상태를 직접 바꾸려고 해서는 안 됩니다. 모든 변경은 정해진 액션을 통해서만 이루어져야 합니다.
    -   **상태 변경의 중앙화:** 특정 상태를 변경하는 코드는 오직 한 곳(해당 상태의 액션 함수)에만 존재해야 합니다. 여러 곳에서 동일한 상태를 제멋대로 변경하면, 버그 추적이 극도로 어려워집니다.

### 4. 상태는 "불변(Immutable)"하게 다루어라

> 과거를 바꾸지 마라. 새로운 역사를 써라.

-   **지침:**
    -   **직접 수정 금지:** 객체나 배열을 직접 수정(`state.user.name = 'new'`)하는 것은 최악의 버그를 만듭니다. React는 참조가 바뀌지 않으면 변화를 감지하지 못해 렌더링이 일어나지 않을 수 있습니다.
    -   **새로운 사본 생성:** 항상 스프레드 연산자(`{...state, user: {...state.user, name: 'new'}}`), `map`, `filter` 등을 사용해 새로운 객체나 배열을 만들어 반환하십시오.
    -   **`immer` 도입 고려:** 복잡한 중첩 객체를 다룰 때, 불변성을 지키기 위한 코드는 매우 길고 지저분해질 수 있습니다. `immer` 라이브러리는 "직접 수정하는 것처럼" 코드를 작성해도 내부적으로 불변성을 완벽하게 보장해주므로, 코드의 가독성과 안정성을 동시에 높일 수 있는 강력한 도구입니다.

---

## 실천 체크리스트

새로운 기능을 추가하거나 코드를 리팩토링할 때, 다음 질문에 답해보십시오.

-   [ ] 이 로직은 순수한 데이터를 다루는가, 아니면 외부와 통신하거나 시간을 필요로 하는 복잡한 행위인가? (→ 원칙 1)
-   [ ] 이 상태는 게임의 핵심 규칙에 속하는가, 아니면 단순히 화면에 보여주기 위한 시각 효과인가? (→ 원칙 2)
-   [ ] 이 상태 변경은 정해진 액션을 통해 한 방향으로만 흐르는가? (→ 원칙 3)
-   [ ] 상태를 업데이트할 때, 원본을 직접 건드리지 않고 새로운 복사본을 만들었는가? (→ 원칙 4)

이 지침들이 복잡한 상태 관리와의 싸움에서 승리하는 데 도움이 되기를 바랍니다.
